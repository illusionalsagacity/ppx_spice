// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Zora from "zora";
import * as Spice from "../../../src/Spice.mjs";
import * as EncodeDecode from "../../../src/EncodeDecode.mjs";
import * as Stdlib_Option from "@rescript/runtime/lib/es6/Stdlib_Option.js";

function testEqual(t, name, lhs, rhs) {
  t.test(name, async t => {
    t.equal(lhs, rhs, name);
  });
}

Zora.test("encode only", t => {
  let sample = {
    name: "Alice",
    nickname: "Ecila"
  };
  let sampleJson = sample;
  let encoded = EncodeDecode.te_encode({
    name: "Alice",
    nickname: "Ecila"
  });
  testEqual(t, "encode", encoded, sampleJson);
});

Zora.test("decode only", t => {
  let sample = {
    name: "Alice",
    nickname: "Ecila"
  };
  let sampleJson = sample;
  let decoded = EncodeDecode.td_decode(sampleJson);
  testEqual(t, "decode", decoded, {
    TAG: "Ok",
    _0: {
      name: "Alice",
      nickname: "Ecila"
    }
  });
});

function inner_decode(v) {
  if (typeof v !== "object" || v === null || Array.isArray(v)) {
    return Spice.error(undefined, "Not an object", v);
  }
  let value = Stdlib_Option.getOr(Stdlib_Option.map(v["value"], Spice.intFromJson), Spice.error(undefined, "value" + " missing", v));
  if (value.TAG === "Ok") {
    return {
      TAG: "Ok",
      _0: {
        value: value._0
      }
    };
  }
  let e = value._0;
  return Spice.error("." + ("value" + e.path), e.message, e.value);
}

function outer_decode(v) {
  if (typeof v !== "object" || v === null || Array.isArray(v)) {
    return Spice.error(undefined, "Not an object", v);
  }
  let inner = Stdlib_Option.getOr(Stdlib_Option.map(v["inner"], inner_decode), Spice.error(undefined, "inner" + " missing", v));
  if (inner.TAG === "Ok") {
    return {
      TAG: "Ok",
      _0: {
        inner: inner._0
      }
    };
  }
  let e = inner._0;
  return Spice.error("." + ("inner" + e.path), e.message, e.value);
}

function arrayWrapper_decode(v) {
  if (typeof v !== "object" || v === null || Array.isArray(v)) {
    return Spice.error(undefined, "Not an object", v);
  }
  let arr = Stdlib_Option.getOr(Stdlib_Option.map(v["arr"], extra => Spice.arrayFromJson(Spice.intFromJson, extra)), Spice.error(undefined, "arr" + " missing", v));
  if (arr.TAG === "Ok") {
    return {
      TAG: "Ok",
      _0: {
        arr: arr._0
      }
    };
  }
  let e = arr._0;
  return Spice.error("." + ("arr" + e.path), e.message, e.value);
}

Zora.test("decode error path", t => {
  t.test("nested record path", async t => {
    let json = {
      inner: {
        value: "not an int"
      }
    };
    let result = outer_decode(json);
    if (result.TAG === "Ok") {
      t.fail("should have failed");
      return;
    }
    t.equal(result._0.path, ".inner.value", "path should be .inner.value");
  });
  t.test("array index path", async t => {
    let json = {
      arr: [
        1.0,
        "bad"
      ]
    };
    let result = arrayWrapper_decode(json);
    if (result.TAG === "Ok") {
      t.fail("should have failed");
      return;
    }
    t.equal(result._0.path, ".arr[1]", "path should be .arr[1]");
  });
});

function v_decode(v) {
  if (!Array.isArray(v)) {
    return Spice.error(undefined, "Not a variant", v);
  }
  if (v.length === 0) {
    return Spice.error(undefined, "Expected variant, found empty array", v);
  }
  let match = v[0];
  if (match === "A") {
    if (v.length !== 2) {
      return Spice.error(undefined, "Invalid number of arguments to variant constructor", v);
    }
    let v0 = Spice.intFromJson(v[1]);
    if (v0.TAG === "Ok") {
      return {
        TAG: "Ok",
        _0: {
          TAG: "A",
          _0: v0._0
        }
      };
    }
    let e = v0._0;
    return Spice.error("[1]" + e.path, e.message, e.value);
  }
  return Spice.error(undefined, "Invalid variant constructor", v[0]);
}

Zora.test("variant error path", t => {
  t.test("variant arg path", async t => {
    let json = [
      "A",
      "bad"
    ];
    let result = v_decode(json);
    if (result.TAG === "Ok") {
      t.fail("should have failed");
      return;
    }
    t.equal(result._0.path, "[1]", "path should be [1]");
  });
});

function pv_decode(v) {
  if (!Array.isArray(v)) {
    return Spice.error(undefined, "Not a polyvariant", v);
  }
  if (v.length === 0) {
    return Spice.error(undefined, "Expected polyvariant, found empty array", v);
  }
  let match = v[0];
  if (typeof match === "string") {
    switch (match) {
      case "A" :
        if (v.length !== 2) {
          return Spice.error(undefined, "Invalid number of arguments to polyvariant constructor", v);
        }
        let v0 = Spice.intFromJson(v[1]);
        if (v0.TAG === "Ok") {
          return {
            TAG: "Ok",
            _0: {
              NAME: "A",
              VAL: v0._0
            }
          };
        }
        let e = v0._0;
        return Spice.error("[1]" + e.path, e.message, e.value);
      case "B" :
        if (v.length !== 4) {
          return Spice.error(undefined, "Invalid number of arguments to polyvariant constructor", v);
        }
        let v0$1 = Spice.intFromJson(v[1]);
        if (v0$1.TAG === "Ok") {
          let v1 = Spice.stringFromJson(v[2]);
          if (v1.TAG === "Ok") {
            let v2 = Spice.floatFromJson(v[3]);
            if (v2.TAG === "Ok") {
              return {
                TAG: "Ok",
                _0: {
                  NAME: "B",
                  VAL: [
                    v0$1._0,
                    v1._0,
                    v2._0
                  ]
                }
              };
            }
            let e$1 = v2._0;
            return Spice.error("[3]" + e$1.path, e$1.message, e$1.value);
          }
          let e$2 = v1._0;
          return Spice.error("[2]" + e$2.path, e$2.message, e$2.value);
        }
        let e$3 = v0$1._0;
        return Spice.error("[1]" + e$3.path, e$3.message, e$3.value);
    }
  }
  return Spice.error("[0]", "Invalid polymorphic variant constructor", v[0]);
}

Zora.test("polyvariant error path", t => {
  t.test("polyvariant case path", async t => {
    let json = [
      "C",
      "bad"
    ];
    let result = pv_decode(json);
    if (result.TAG === "Ok") {
      t.fail("should have failed");
      return;
    }
    let e = result._0;
    t.equal(e.message, "Invalid polymorphic variant constructor", "message should be 'Invalid polymorphic variant constructor'");
    t.equal(e.path, "[0]", "path should be [0]");
  });
  t.test("polyvariant arg path", async t => {
    let json = [
      "A",
      "bad"
    ];
    let result = pv_decode(json);
    if (result.TAG === "Ok") {
      t.fail("should have failed");
      return;
    }
    t.equal(result._0.path, "[1]", "path should be [1]");
  });
  t.test("polyvariant multi-arg path", async t => {
    let json = [
      "B",
      1.0,
      "good",
      "bad"
    ];
    let result = pv_decode(json);
    if (result.TAG === "Ok") {
      t.fail("should have failed");
      return;
    }
    t.equal(result._0.path, "[3]", "path should be [3]");
  });
});

function tupleWrapper_decode(v) {
  if (typeof v !== "object" || v === null || Array.isArray(v)) {
    return Spice.error(undefined, "Not an object", v);
  }
  let t = Stdlib_Option.getOr(Stdlib_Option.map(v["t"], json => {
    if (!Array.isArray(json)) {
      return Spice.error(undefined, "Not a tuple", json);
    }
    if (json.length !== 4) {
      return Spice.error(undefined, "Incorrect cardinality", json);
    }
    let v0 = json[0];
    let v1 = json[1];
    let v2 = json[2];
    let v3 = json[3];
    let v0$1 = Spice.intFromJson(v0);
    if (v0$1.TAG === "Ok") {
      let v1$1 = Spice.stringFromJson(v1);
      if (v1$1.TAG === "Ok") {
        let v2$1 = Spice.intFromJson(v2);
        if (v2$1.TAG === "Ok") {
          let v3$1 = Spice.floatFromJson(v3);
          if (v3$1.TAG === "Ok") {
            return {
              TAG: "Ok",
              _0: [
                v0$1._0,
                v1$1._0,
                v2$1._0,
                v3$1._0
              ]
            };
          }
          let e = v3$1._0;
          return {
            TAG: "Error",
            _0: {
              path: "[3]" + e.path,
              message: e.message,
              value: e.value
            }
          };
        }
        let e$1 = v2$1._0;
        return {
          TAG: "Error",
          _0: {
            path: "[2]" + e$1.path,
            message: e$1.message,
            value: e$1.value
          }
        };
      }
      let e$2 = v1$1._0;
      return {
        TAG: "Error",
        _0: {
          path: "[1]" + e$2.path,
          message: e$2.message,
          value: e$2.value
        }
      };
    }
    let e$3 = v0$1._0;
    return {
      TAG: "Error",
      _0: {
        path: "[0]" + e$3.path,
        message: e$3.message,
        value: e$3.value
      }
    };
  }), Spice.error(undefined, "t" + " missing", v));
  if (t.TAG === "Ok") {
    return {
      TAG: "Ok",
      _0: {
        t: t._0
      }
    };
  }
  let e = t._0;
  return Spice.error("." + ("t" + e.path), e.message, e.value);
}

function dictWrapper_decode(v) {
  if (typeof v !== "object" || v === null || Array.isArray(v)) {
    return Spice.error(undefined, "Not an object", v);
  }
  let d = Stdlib_Option.getOr(Stdlib_Option.map(v["d"], extra => Spice.dictFromJson(Spice.intFromJson, extra)), Spice.error(undefined, "d" + " missing", v));
  if (d.TAG === "Ok") {
    return {
      TAG: "Ok",
      _0: {
        d: d._0
      }
    };
  }
  let e = d._0;
  return Spice.error("." + ("d" + e.path), e.message, e.value);
}

Zora.test("other types error path", t => {
  t.test("tuple path", async t => {
    let json = {
      t: [
        1.0,
        "ok",
        "bad",
        4.0
      ]
    };
    let result = tupleWrapper_decode(json);
    if (result.TAG === "Ok") {
      t.fail("should have failed");
      return;
    }
    t.equal(result._0.path, ".t[2]", "path should be .t[2]");
  });
  t.test("dict path", async t => {
    let json = {
      d: {
        a: "bad"
      }
    };
    let result = dictWrapper_decode(json);
    if (result.TAG === "Ok") {
      t.fail("should have failed");
      return;
    }
    t.equal(result._0.path, ".d.a", "path should be .d.a");
  });
});

export {
  testEqual,
  inner_decode,
  outer_decode,
  arrayWrapper_decode,
  v_decode,
  pv_decode,
  tupleWrapper_decode,
  dictWrapper_decode,
}
/*  Not a pure module */
